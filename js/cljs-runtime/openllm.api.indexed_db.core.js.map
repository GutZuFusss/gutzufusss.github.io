{"version":3,"sources":["openllm/api/indexed_db/core.cljs"],"mappings":"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","names":["openllm.api.indexed-db.core/READ_WRITE","openllm.api.indexed-db.core/READ_ONLY","openllm.api.indexed-db.core/name->db","cljs.core.atom","openllm.api.indexed-db.core/idb-error-callback","e","openllm.api.log4cljs.core.log","openllm.api.indexed-db.core/create-transaction","obj-store-fqn","mode","map__36590","cljs.core/--destructure-map","cljs.core.get","db-name","os-name","db","cljs.core/deref","transaction","openllm.api.indexed-db.core/on-upgrade-needed!","table-info","user-callback","old-version","new-version","cljs.core.ex_info","G__36593","G__36594","openllm.api.indexed-db.core/create-object-store!","openllm.api.indexed-db.core/on-initialize-success!","cljs.core.swap_BANG_","cljs.core/assoc","map__36602","object-store","iter__5523__auto__","s__36605","cljs.core/LazySeq","temp__5753__auto__","cljs.core/seq","cljs.core/chunked-seq?","c__5521__auto__","size__5522__auto__","cljs.core/count","b__36607","cljs.core/chunk-buffer","i__36606","cljs.core/-nth","cljs.core/chunk-append","cljs.core/chunk-cons","cljs.core/chunk","iter__36604","cljs.core/chunk-rest","cljs.core/first","cljs.core/cons","cljs.core/rest","table-idx","openllm.api.indexed-db.core/os-add!","entry","cljs.core/clj->js","openllm.api.indexed-db.core/os-add-all!","entries","cljs.core/vector?","cljs.core/empty?","openllm.api.indexed-db.core/os-index->object","idx","callback-fn","request","G__36615","openllm.api.indexed-db.core/os-get-all","values","temp__5751__auto__","cursor","cljs.core/conj","G__36655","openllm.api.indexed-db.core/wipe-object-store!","var_args","G__36691","openllm.api.indexed-db.core/initialize!","js/Error","db-info","openllm.api.indexed_db.core.initialize_BANG_","success-callback","on-upgrade-db-version","map__36695","db-version","upgrade-callback!","cljs.core.partial","js/window","cljs.core/chunk-first"],"sourcesContent":["(ns openllm.api.indexed-db.core\n  \"This namespace is a wrapper for the IndexedDB API. It provides\n   functions to create object stores, add objects to them and retrieve\n   objects from them.\n\n   The functions in this namespace are meant to be used by other\n   namespaces, which will provide a higher level API for the application\n   to use.\n\n   If you stumble upon a parameter named `obj-store-fqn`, this is the fully\n   qualified name of the object store. This name (or identifier rather)\n   must consist of a map with two keys: `:db-name` and `:os-name`. `:db-name`\n   must be a string, which identifies the database. `:os-name` must be a\n   string, which is the name of the object store.\"\n  (:require [openllm.api.log4cljs.core :refer [log]]))\n\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;             Private API            ;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n(def ^:private ^:const READ_WRITE \"readwrite\")\n(def ^:private ^:const READ_ONLY \"readonly\")\n\n(declare create-object-store!)\n\n(def ^:private ^:const name->db\n  \"This map will hold the database objects for each database name.\n   The database name is the key and the database object is the value.\n   This map is used to prevent the creation of multiple database objects\n   for the same database name. This is important, because the database\n   object is the only way to interact with the database.\n   \n   The lookup into this map is automatically done. While using an atom\n   adds state to the namespace, the performance and convinience gains\n   are worth it.\"\n  (atom {}))\n\n(defn- idb-error-callback\n  \"This function is called when an error occurs during an IndexedDB\n   request.\n   It will log the error to the browser's console.\"\n  [e]\n  (log :error \"Error during IndexedDB request\" e))\n\n(defn- create-transaction\n  \"Create a transaction for the object store identified by the\n   `obj-store-fqn` (see namespace docstring for more information). This\n   function is meant to be used by the object store ('os-*') functions.\n   This function will create a transaction and return the object store,\n   which can be used to interact with the database right away.\n\n   We consider this function semi-pure since there are no *notable*\n   direct side effects.\"\n  [obj-store-fqn mode]\n  (let [{:keys [db-name os-name]} obj-store-fqn\n        db (get @name->db db-name)\n        transaction (.transaction db #js [os-name] mode)]\n    (set! (.-onerror transaction) idb-error-callback)\n    (-> transaction\n        (.objectStore os-name))))\n\n(defn- on-upgrade-needed!\n  \"This function is called as a callback when the database is upgraded.\n   It will create the object stores for the application and and save the\n   backing database in the app-db for later use.\n\n   There are two possible reasons that the database got upgraded:\n   1. The database did not exist before and was created.\n   2. The database existed before, but the version (and presumably the\n      schema) was lower/older than the current version.\n\n   Returns `nil`.\"\n  [table-info user-callback e]\n  (let [db (.. e -target -result)\n        old-version (.-oldVersion db)\n        new-version (.-version db)]\n    (when (and (> 0 old-version) (nil? user-callback))\n      (throw\n       (ex-info \"The database version was upgraded, but no 'on-upgrade-db-version' callback was provided to 'initialize!'.\"\n                {:old-version old-version :new-version new-version})))\n    (if (some? user-callback)\n      (do (log :info (str \"Received upgrade needed event, current version is \" new-version \", old version is \" old-version \". Calling user callback.\"))\n          (user-callback old-version new-version))\n      (do (log :info (str \"Database and object store created. Current database version is \" (.-version db) \".\"))\n          (create-object-store! {:db-name db :os-name (:name table-info)} table-info)))\n    nil))\n\n(defn- on-initialize-success!\n  \"This function is called as a callback when the database is initialized.\n   It will save the database object in our `name->db` atom for later use.\n\n   Returns `nil`.\"\n  [db-name user-callback e]\n  (let [db (.. e -target -result)]\n    (swap! name->db assoc db-name db)\n    (user-callback)\n    (log :debug \"Database initialized and callback function triggered.\" e))\n  nil)\n\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;             Public API             ;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n(defn create-object-store!\n  \"Create an object store identified by the `obj-store-fqn` (see namespace\n   docstring for more information) inside a database. The `:os-name` key of\n   the `obj-store-fqn` parameter can be chosen freely, but it must be unique\n   within the database (see namespace docstring for more info) and it should\n   match the `:name` key of the `table-info` parameter. The `table-info`\n   parameter must be a map with the following structure:\n    ```clojure\n    {:name \\\"my-obj-store-name\\\"\n     :index [{:name \\\"my-field\\\"\n              :unique false}]}\n    ```\n   The `:index` key is a vector of maps, each of which will describe one\n   index (aka field) of the object store. The `:name` key of the index map\n   must be unique within the object store.\n\n   Will return the object store object with an open transaction attached,\n   so that it can be used right away.\"\n  [obj-store-fqn table-info]\n  (let [{:keys [db-name os-name]} obj-store-fqn\n        db (get @name->db db-name)\n        object-store (.createObjectStore db os-name #js {:keyPath \"id\" :autoIncrement true})]\n    (for [table-idx (:index table-info)]\n      (.createIndex\n       object-store\n       (:name table-idx) (:name table-idx) #js {:unique (:unique table-idx)}))\n    (set! (.. object-store -transaction -oncomplete)\n          #(-> db\n               (.transaction os-name READ_WRITE)\n               (.objectStore os-name)))))\n\n(defn os-add!\n  \"Add a single object to the given object store identified by the\n   `obj-store-fqn` (see namespace docstring for more information). This\n   function will create a transaction and add the object to the object store.\n\n   Returns `nil`.\"\n  [obj-store-fqn entry]\n  (let [object-store (create-transaction obj-store-fqn READ_WRITE)]\n    (-> object-store\n        (.put (clj->js entry))))\n  nil)\n\n(defn os-add-all!\n  \"Add an vector of objects to the given object store identified by the\n   `obj-store-fqn` (see namespace docstring for more information). This\n   function will create a transaction and add the objects to the object store.\n   Note that we create a new transaction for each object.\n   TODO: Figure out if there is a way with clojure looping constructs to\n   create a single transaction and add all objects to the object store\n   at once.\n\n   An exception will be thrown, if the second argument is not a vector!\n   There are no guarantees that the objects will be added in the excpected\n   order if the algorithm is not adjusted, so for not no other collections\n   are allowed.\n\n   Returns `nil`.\"\n  [obj-store-fqn entries]\n  (when-not (vector? entries)\n    (throw\n     (ex-info \"os-add-all! expects a vector of objects as its third argument.\"\n              {:entries entries})))\n  (loop [entries entries]\n    (if (empty? entries)\n      nil\n      (do (os-add! obj-store-fqn (first entries))\n          (recur (rest entries))))))\n\n(defn os-index->object\n  \"Use this function to retrieve a single object from the object store. In\n   order to retrieve all objects from the object store, use the function\n   `os-get-all` instead.\n   You will need to pass `callback-fn`, which must be a function that takes\n   a single argument. This argument will be the object that was retrieved\n   from the object store.\n\n   Returns `nil`.\"\n  [obj-store-fqn idx callback-fn]\n  (let [object-store (create-transaction obj-store-fqn READ_ONLY)\n        request (.get object-store idx)]\n    (set! (.-onerror request) idb-error-callback)\n    (set! (.-onsuccess request)\n          (fn [e]\n            (callback-fn (.-result (.-target e))))))\n  nil)\n\n(defn os-get-all\n  \"Get all objects from the object store identified by the `obj-store-fqn`\n   (see namespace docstring for more information). This function will create\n   a transaction and get all objects from the object store.\n   `callback-fn` should be a function that takes a vector of objects\n   as its only argument.\n\n   It is up for discussion, whether this function should be considered\n   to have side effects or not. I think it should be given some thoughts,\n   because it opens a transaction and thus locks the data-base, and it\n   will call the `callback-fn` with the objects from the object store.\n\n   Returns `nil`.\"\n  [obj-store-fqn callback-fn]\n  (let [values (atom []) ;; TODO: grrr\n        request\n        (->\n         (create-transaction obj-store-fqn READ_ONLY)\n         .openCursor)]\n    (set! (.-onerror request) idb-error-callback)\n    (set! (.-onsuccess request)\n          (fn [e]\n            (if-let [cursor (.. e -target -result)]\n              (do\n                (swap! values conj (.-value cursor))\n                (.continue cursor))\n              (callback-fn @values)))))\n  nil)\n\n(defn wipe-object-store!\n  \"Wipe the object store identified by the `obj-store-fqn`, see the\n   docstring of this namespace for more information.\n   This function should be used with great care, as the wipe will not be\n   reversible. It will create a transaction and clear the object store.\n\n   Returns `nil`.\"\n  [obj-store-fqn]\n  (let [object-store (create-transaction obj-store-fqn READ_WRITE)\n        transaction (.-transaction object-store)]\n    (set! (.-oncomplete transaction) #(log :info \"Object store wiped.\"))\n    (set! (.-onerror transaction) idb-error-callback)\n    (.clear object-store))\n  nil)\n\n(defn initialize!\n  \"Initialize the indexed-db. This function should be called once\n   when the application starts. The `db-init-callback` function will\n   be called when the database is initialized.\n   You should retain the db-name and os-name, as they are required to\n   interact with the database and object store. For more information see:\n   `obj-store-fqn` docstring of this namespace.\n\n   The `table-info` parameter must be a map with the following structure:\n    ```clojure\n    {:name \\\"my-obj-store-name\\\"\n     :index [{:name \\\"my-field\\\"\n              :unique false}]}\n    ```\n   The `:index` key is a vector of maps, each of which will describe one\n   index (the equivalend of a field in a SQL table) of the object store.\n\n   Optionally, you may pass a `success-callback` function, which will be\n   called when the database is initialized. The function will be called\n   with no arguments.\n\n   Also optionally, you can pass an `on-upgrade` callback function, which\n   will be called when the database is upgraded to a new version. The\n   function will be called with the old version number as its first\n   and the new version as it's second argument. If you do pass a function,\n   it will be called *instead* of the default callback function. This\n   means, that you will have to create the object store yourself!\n   An example of how to do this:\n   ```clojure\n   (create-object-store! {:db-name db-name :os-name store-name}\n                         your-table-definition)\n   ```\n\n   Returns `nil`.\"\n  ([db-info table-info] (initialize! db-info table-info nil nil))\n  ([db-info table-info success-callback] (initialize! db-info table-info success-callback nil))\n  ([db-info table-info success-callback on-upgrade-db-version]\n   (let [{:keys [db-name db-version]} db-info\n         upgrade-callback! (partial on-upgrade-needed!\n                                    table-info\n                                    on-upgrade-db-version)\n         request (.open\n                  (. js/window -indexedDB)\n                  db-name db-version)]\n     (set! (.-onerror request) idb-error-callback)\n     (set! (.-onupgradeneeded request) upgrade-callback!)\n     (set! (.-onsuccess request) (partial on-initialize-success! db-name success-callback)))\n   nil))\n\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;           Rich Comments            ;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n(comment\n  (def db-name \"test-db\") ;; => [\"test-db\"]\n\n  (def obj-store-name \"chat-history\") ;; => [\"chat-history\"]\n\n  (def obj-store-fqn {:db-name db-name :os-name obj-store-name})\n\n  (def test-messages [{:user :user :text \"Hey\"}\n                      {:user :model :text \"Hey, how are you?\"}\n                      {:user :user :text \"I'm fine, thanks.\"}\n                      {:user :model :text \"That's good to hear.\"}])\n\n\n  ;; very simple sanity check\n  (. js/window -indexedDB) ;; => #object[IDBFactory [object IDBFactory]]\n\n\n  ;; initialize the database and creates the object stores\n  (initialize! {:db-name \"test-db\" :db-version 1}\n               {:name \"chat-history\"\n                :index [{:name \"user\"\n                         :unique false}]}\n               nil) ;; => nil\n\n\n  ;; add a single test message to the object store\n  (os-add! obj-store-fqn\n           {:user :model :text \"test message\"}) ;; => nil\n\n\n  ;; add the test messages from above to the object store\n  (os-add-all! obj-store-fqn\n               test-messages) ;; => nil\n\n\n  ;; get the second object from the object store\n  (os-index->object obj-store-fqn\n                    2\n                    #(print (js->clj % :keywordize-keys true))) ;; => nil\n  ;; and prints: {:user :user, :text Hey}\n\n\n  ;; get all objects from the object store\n  (os-get-all obj-store-fqn\n              #(print (js->clj % :keywordize-keys true))) ;; => nil\n   ;; and prints a vector of size 5 with the test messages added above\n\n\n\n  ;; this will wipe the object store\n  (wipe-object-store! obj-store-fqn))\n"]}