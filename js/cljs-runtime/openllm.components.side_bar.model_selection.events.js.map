{"version":3,"sources":["openllm/components/side_bar/model_selection/events.cljs"],"mappings":";AAYA,uBAAA,vBAACA,mNAEA,WAAKC,KAAKC;AAAV,AACE,0DAAA,nDAACC,8CAAMF,mKAGI,XACA,AAACG,1DACD,q/FAAA,2EAAA,hkGAACC;;AAUf,yDAAA,2KAAA,pOAACC,uTAECC,8CACD,cAAAC,HAAKG;AAAL,AAAA,IAAAF,aAAAD;QAAA,AAAAE,4CAAAD,WAAA,IAAA,/DAASP;iBAAT,AAAAQ,4CAAAD,WAAA,IAAA,xEAAWG;AAAX,AACE,OAACC,mBAASF,GAAG,8IAAA,yEAAA,vNAACG,6RAAwCF;;AAEzD,yDAAA,wKAAA,jOAACN,oTAECC,8CACD,cAAAQ,HAAKJ;AAAL,AAAA,IAAAK,aAAAD;QAAA,AAAAL,4CAAAM,WAAA,IAAA,/DAASd;eAAT,AAAAQ,4CAAAM,WAAA,IAAA,tEAAWC;AAAX,AACE,OAACJ,mBAASF,GAAG,8IAAA,yEAAA,vNAACG,0RAAsCG;;AAQvD,yDAAA,uFAAA,hJAACC,mOAECX,sCAAuB,wDAAA,xDAACY,6PACzB,WAAAC,SAAyClB;AAAzC,AAAA,IAAAmB,aAAAD;IAAAC,iBAAA,AAAAC,4BAAAD;SAAA,AAAAE,4CAAAF,eAAA,hEAAaV;6BAAb,AAAAY,4CAAAF,eAAA,pFAAgBG;AAAhB,AAAA,kDAAA,gDACO,iBAAMC,aAAW,AAACF,4CAAIZ,GAAG,8IAAA,9IAACG;AAA1B,AACE,GAAI,EAAI,AAACY,6CAAEC,4DAAgBF,iBAAY,eAAA,dAAMA;AAC3C,OAACZ,mBAASF,GAAG,8IAAA,9IAACG,qNAAwBU;;AACtC,AAAI,mEAAA,uGAAA,1KAACI,6PAA6FH;;AAC9Fd;;;;AAEhB,yDAAA,kKAAA,3NAACO,4PAGA,aAAAW,FAAK3B;AAAL,AAAA,IAAA4B,aAAAD;YAAA,AAAAnB,4CAAAoB,WAAA,IAAA,nEAAQ5B;YAAR,AAAAQ,4CAAAoB,WAAA,IAAA,nEAAUC;AAAV,AAAA,kDAAA,kDAAA,mFACQ,mEAAA,yGAAA,5KAACH,6MAA4CG;;AAEtD,yDAAA,iLAAA,1OAACb,6TAECX,8CACD,aAAAyB,FAAK9B;AAAL,AAAA,IAAA+B,aAAAD;YAAA,AAAAtB,4CAAAuB,WAAA,IAAA,nEAAQ/B;eAAR,AAAAQ,4CAAAuB,WAAA,IAAA,tEAAUC;AAAV,AACE,IAAMtB,oLAAesB,hGACA,AAAA,vBACA,iIAAA,IAAA,rIAACC,hDACD,AAACC;IAChBnB,WAAS,AAAA,4FAAWiB;AAJ1B,AAAA,kDAAA,iEAAA,mFAAA,mFAAA,8LAAA,mFAAA,tGAKkCtB,8QACFK;;AAEnC,yDAAA,2FAAA,pJAACC,qLAGA,WAAKhB,EAAEA;AAAP,AAAA,kDAAA,6DAAA,mFAAA,kGAAA,GAAA,2CAAA,iEAAA,mFAAA,yLAAA,gEAAA,mFAAA","names":["re-frame.core/reg-cofx","cofx","_","cljs.core.assoc","js/JSON.parse","cljs.core.js__GT_clj","re_frame.core.reg_event_db","openllm.events/check-spec-interceptor","p__40364","vec__40365","cljs.core.nth","db","model-type","cljs.core/assoc-in","openllm.components.side_bar.model_selection.db.key_seq","p__40368","vec__40369","model-id","re_frame.core.reg_event_fx","re_frame.core.inject_cofx","p__40372","map__40373","cljs.core/--destructure-map","cljs.core.get","model-data-json-parsed","all-models","cljs.core._EQ_","openllm.components.side-bar.model-selection.db/loading-text","openllm.api.log4cljs.core.log","p__40374","vec__40375","error","p__40378","vec__40379","metadata","clojure.string/replace","cljs.core.keyword"],"sourcesContent":["(ns openllm.components.side-bar.model-selection.events\n  (:require [openllm.components.side-bar.model-selection.db :as db]\n            [openllm.events :refer [check-spec-interceptor]]\n            [re-frame.core :refer [reg-event-db reg-event-fx reg-cofx inject-cofx]]\n            [openllm.api.http :as api] \n            [openllm.api.log4cljs.core :refer [log]]\n            [clojure.string :as str])\n  (:require-macros [openllm.build :refer [slurp]]))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;             Coeffects              ;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n(reg-cofx\n ::model-data-json-parsed\n (fn [cofx _]\n   (assoc cofx\n          :model-data-json-parsed\n          (-> \"./src/generated/models-data.json\"\n              (slurp ,) ;; look @ `openllm.build/slurp` to see how this sorcery works\n              (js/JSON.parse ,)\n              (js->clj , :keywordize-keys true)))))\n\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;               Events               ;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; Sets the `model-type` in the db to the selected model-type. It also sets the\n;; `model-id` to the first `model-id` of the selected `model-type`.\n;; This event is dispatched by the `model-type` dropdown in the `views.cljs`\n;; namespace of this component.\n(reg-event-db\n ::set-model-type\n [check-spec-interceptor]\n (fn [db [_ model-type]]\n   (assoc-in db (db/key-seq :selected-model :model-type) model-type)))\n\n(reg-event-db\n ::set-model-id\n [check-spec-interceptor]\n (fn [db [_ model-id]]\n   (assoc-in db (db/key-seq :selected-model :model-id) model-id)))\n\n;; This event is dispatched by the `initial-db` function in `db.cljs`. It\n;; slurps the model data json file and parses it into a clojure map. It then\n;; checks if the db already contains data. If it does, it logs a warning and\n;; does nothing. If it doesn't, it adds the parsed data to the db.\n;; The `models-data.json` file is generated by the `generate-models-data-json`\n;; hook in `build.clj` (from JVM Clojure).\n(reg-event-fx\n :slurp-model-data-json\n [check-spec-interceptor (inject-cofx ::model-data-json-parsed)]\n (fn [{:keys [db model-data-json-parsed]} _]\n   {:db (let [all-models (get db (db/key-seq :all-models))]\n          (if (or (= db/loading-text all-models) (nil? all-models))\n            (assoc-in db (db/key-seq :all-models) model-data-json-parsed)\n            (do (log :warn \"Attempted to slurp and parse model data json, but the db already contained data:\" all-models)\n                db)))}))\n\n(reg-event-fx\n ::log-error\n []\n (fn [_ [_ error]]\n   {:fx [(log :error \"Error while fetching metadata:\" error)]}))\n\n(reg-event-fx\n ::received-metadata\n [check-spec-interceptor]\n (fn [_ [_ metadata]]\n   (let [model-type (-> metadata\n                        (:model_name ,)\n                        (str/replace , \"_\" \"-\")\n                        (keyword ,))\n         model-id (:model_id metadata)]\n     {:dispatch-n [[::set-model-type model-type]\n                   [::set-model-id model-id]]})))\n\n(reg-event-fx\n :fetch-metadata-endpoint\n []\n (fn [_ _]\n   {:dispatch [::api/v1-metadata \"\"\n               {:on-success [::received-metadata]\n                :on-failure [::log-error]}]}))\n"]}